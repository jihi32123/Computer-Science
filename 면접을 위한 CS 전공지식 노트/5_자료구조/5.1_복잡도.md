# 5.1 복잡도
복잡도는 시간 복잡도와 공간 복잡도로 나뉜다. 

## 5.1.1 시간 복잡도
### C++의 기본
시간 복잡도를 알아보기 전, C++의 기본을 먼저 알아보자.

``` C++ 
#include <bits/stdc+++.h> // ---(1)
using namepsace  std;     // ---(2)
string a;                 // ---(3)
int main(){               
    cin >> a;             // ---(4)
    cout << a << "\n";    // ---(5)
    return 0;             // ---(6)
}
```
위의 코드는 입력한 값을 그대로 출력한다. 
C++는 main 함수를 중심으로 돌아가기 때문에 main 함수를 무조건 만들고, 이후 컴파일이 시작되면 전역변수 초기화, 라이브러리 import 등의 작업이 일어나고, main 함수에 얽혀 있는 함수들이 작동된다. 
마지막으로 메인 프로세스가 0을 리턴하며 종료한다. 

위의 코드를 순서대로 설명하면 아래와 같다. 
1. 헤더 파일이다. STL 라이브러리를 import 한다.  이 중 bits/stdc++.h는 모든 표준 라이브러리가 포함되 ㄴ헤더이다. 
2. std라는 네임스페이스를 사용한다는 뜻. cin이나 cout 등을 사용할 때 원래는 std::cin 처럼 네임스페이스를 달아서 호출해야 하는데, 이를 기본으로 설정한다는 뜻이다. 참고로 네임스페이스는 같은 클래스 이름 구별, 모듈화에 쓰이는 이름을 말한다. 
3. 문자열을 선언부, string이라는 타입을 가진 a 라는 변수를 정의했다. 
    string a = "bimo"라고 선언했을 때 a를 lvalue라고 하며  bimo를 rvalue라고 한다. 
    rvalue는 다시 사용할 수 있는 변수이며 rvalue는 한 번 쓰고 다시 사용되지 않느 ㄴ변수를 말한다. 
4. 입력, 대표적으로 cin, scanf가 있다. 
5. 출력, 대표적으로 cout과 printf가 있다. 
6. return 0이다. 프로세스가 정상적으로 마무리됨을 뜻한다.  

### 빅오 표기법 
시간 복잡도란 '문제를 해결하는데 걸리는 시간과 입력의 함수 관계'를 가리킨다. 
어떠한 알고리즘의 로직이 '얼마나 오랜 시간'이 걸리는지를 나타내는데 쓰이며, 보통 빅오 표기법으로 나타낸다. 
예를 들어 '입력 크기 n'의 모든 입력에 대한 알고리즘에 필요한 시간이 10n<sup>2</sup> + n 이라고 한다면 다음과 같은 코드를 상상할 수 있다. 

```C++
for(int i=0; i <10 ; i++ ){
    for(int j-=0; j< n; j++){
        for(int k=0; k<n; k++){
            if (true) cout << k<< '\n';
        }
    }
}
for(int i=0; i< n; i++){
    if(true)cout<<i<<'\n';
}
```
빅오 표기법이란 입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것이다. 
앞서 말한 코드의 시간 복잡도를 빅오 표기법으로 나타내면 O(n<sup>2</sup>)이 된다. 

'가장 영향을 많이 끼치는' 항의 상수 인자를 빼고 나머지 항을 없앤 것이다. 
입력 크기가 커질 수록 연산량이 가장 많이 커지는 항은 n의 제곱항이고, 다른 것은 그에 비해 미미하기 때문에 이것만 신경 쓰면 된다는 이론이다. 

### 시간 복잡도의 존재 이유
시간 복잡도는 이전 코드를 효율적인 코드로 개선하는데 쓰이는 척도가 된다.

### 시간 복잡도의 속도 비교
![시간 복잡도 속도 비교 그래프 이미지](https://t1.daumcdn.net/cfile/tistory/25047340590B923732)
위의 그림 처럼 O(1)과 O(n)은 입력의 크기가 커질수록 차이가 많이 나는 것을 볼 수 있다. O(n<sup>2</sup>)는 더욱 크다.

## 5.1.2 공간 복잡도
공간 복잡도는 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양을 말한다. 
정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함한다. 

```C++
int a[1004]
```

위의 코드같은 배열이 있다고 하면 a 배열은 1004 * 4 바이트 크기를 가지게 된다. 이런 공간을 의미한다. 

## 5.1.3 자료 구조에서의 시간 복잡도
자료구조를 쓸 때는 이런 시간 복잡도를 잘 생각해야 한다. 
다음은 자주 쓰는 자료구조의 시간 복잡도를 나타낸 모습니다. 
보통 시간 복잡도를 생각할 때 평균, 그리고 최악의 시간 복잡도를 고려하면서 쓴다. 

- 자료  구조의 평균 시간 복잡도

|자료구조|접근|탐색|삽입|삭제|
|:--------------------------|:---|:---|:---|:---|
|배열(array)|O(1)|O(n)|O(n) | O(n)|
|스택(stack)|O(n)| O(n) |O(1) | O(1) | 
|큐(Queue)|O(n) | O(n) | O(1)| O(1) |
|이중 연결 리스트(doubly linked list)|O(n)|O(n)|O(1)|O(1)|
|해시 테이블(hash table)|O(1)|O(1)|O(1)|O(1)|
|이진 탐색 트리(BST)|O(logn)|O(logn)|O(logn)|O(logn)|
|AVL 트리|O(logn)|O(logn)|O(logn)|O(logn)|
|레드 블랙 트리|O(logn)|O(logn)|O(logn)|O(logn)|



- 자료  구조의 최악의 시간 복잡도

|자료구조|접근|탐색|삽입|삭제|
|:--------------------------|:---|:---|:---|:---|
|배열(array)|O(1)|O(n)|O(n) | O(n)|
|스택(stack)|O(n)| O(n) |O(1) | O(1) | 
|큐(Queue)|O(n) | O(n) | O(1)| O(1) |
|이중 연결 리스트(doubly linked list)|O(n)|O(n)|O(1)|O(1)|
|해시 테이블(hash table)|O(n)|O(n)|O(n)|O(n)|
|이진 탐색 트리(BST)|O(n)|O(n)|O(n)|O(n)|
|AVL 트리|O(logn)|O(logn)|O(logn)|O(logn)|
|레드 블랙 트리|O(logn)|O(logn)|O(logn)|O(logn)|
